'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
	var Storage = function () {
		function Storage() {
			_classCallCheck(this, Storage);

			this.apiLoaded = false;
			this.idList = {};
		}

		_createClass(Storage, [{
			key: 'addRecaptcha',
			value: function addRecaptcha(el) {
				var elementId = el.getAttribute('data-captcha-id');

				if (this.idList[elementId] !== undefined) {
					grecaptcha.reset(this.idList[elementId]);
					delete this.idList[elementId];
				}

				var recaptchaId = this.renderRecaptcha(el);
				this.idList[elementId] = recaptchaId;
			}
		}, {
			key: 'renderRecaptcha',
			value: function renderRecaptcha(el) {
				return grecaptcha.render(el, {
					'sitekey': el.getAttribute('data-sitekey'),
					'callback': eval(el.getAttribute('data-callback')),
					'expired-callback': eval(el.getAttribute('data-expired-callback')),
					'theme': el.getAttribute('data-theme'),
					'type': el.getAttribute('data-type'),
					'size': el.getAttribute('data-size'),
					'tabindex': el.getAttribute('data-tabindex')
				});
			}
		}]);

		return Storage;
	}();

	var recaptchaOnloadCallback = function recaptchaOnloadCallback(el) {

		console.log(recaptchasStorage);

		var els = [];

		if (arguments.length === 0) {
			els = document.querySelectorAll('.g-recaptcha');
			recaptchasStorage.apiLoaded = true;
		} else if (!recaptchasStorage.apiLoaded) {
			return false;
		} else {
			els.push(arguments[0]);
		}

		for (var i = 0; i < els.length; i++) {
			recaptchasStorage.addRecaptcha(els[i]);
		}
	};

	if (typeof window.recaptchasStorage === 'undefined') {
		window.recaptchasStorage = new Storage();
	}
	if (typeof window.recaptchaOnloadCallback === 'undefined') {
		window.recaptchaOnloadCallback = recaptchaOnloadCallback;
	}
})();
